



# JAVA

## 并发

### 线程

- 状态转换

  ![](THREAD_STATE_CHANGE.jpg)

### 关键字与JDK源码

  - #### synchronized [参考链接](http://cmsblogs.com/?p=2071)
    
    - 应用 : A a = new A();
      - 锁普通方法 (锁的是A的实例)
      - 锁静态方法 (锁的是A.class)
      - 锁代码块
        - 对象(a,锁的是A的实例)
        - 类 (A.class,锁的是A.class)
    - 问:当两个线程同时执行A类中的普通方法和静态方法是否互斥?答:不互斥,因为是两把不同的锁
    - 原理(字节码层次,在java语言存在两种语法)
      - 语法
        - 锁 --> 代码块
          - 代码块在源码被编译成bytecode时,会在同步代码的入口位置和退出位置分别插入monitorenter,monitorexit字节指令
        - 锁 --> 方法
          - 在字节码层面没有特别的指令实现被synchronized修饰的方法,而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1,表示该方法是同步方法并使用调用该方法的对象或者方法所属的Class在jvm的内部对象表示Klass作为对象锁
      - 对象头
        - synchronized用的锁时存在**对象头**里的
        - 对象头主要包括两部分数据(Mark Work, Klass Pointer)
          - Mark Work (标记字段)
          - Klass Pointer (类型指针)
    
  - ##### volatile

  - **LookSupport**

      - 线程等待唤醒机制(相当于wait/notify 加强版)
      - LockSupport通过许可（permit）实现线程挂起、挂起线程唤醒功能。permit可以理解为每个已启动线程维持的一个int类型状态位counter。线程分别通过执行LockSupport静态方法park()、unPark()方法来完成挂起、唤醒操作。
      - 主要方法
          - java.util.concurrent.locks.LockSupport#park()
              - 唤醒条件
                  - unpark()
                      - 当线程执行park时,判断状态位counte为1,表示拥有许可,立马放行,并将状态位counter设置为0
                      - 当线程执行park时,判断状态位counter为0,表示未获得许可,线程阻塞
              - 响应中断
                  - 当其他线程调用了t.interrupt(),locksupport.park()会效应中断
          - java.util.concurrent.locks.LockSupport#unpark(Thread thread)
            - 现将当前状态为counter设置为1
            - 判断当前线程是否被挂起
                - 挂起,则唤起线程,并将counter设为0
                - 未挂起,无任何操作
    - 面试题
      - 先执行unpark在执行park程序会出现什么情况?
        - 先执行unpark,执行线程与locksupport关联的许可(permit)会被设置成1,当执行park时,会进行状态位判断,因为许可被设置成了1,所以表示当前执行的线程拥有许可,立马放行,并将许可设置成0
      - 先唤醒两次,在阻塞两次会出现什么情况?
        - 会阻塞线程
        - 当执行两次unpark时,会将状态位设置为1,且仅为1,状态位counter最大只能设置为1,也就是许可permit最大为1,所以不管先执行几次unpark,都只能唤醒一个park
    
- **ThreadLocal**

     - private final int threadLocalHashCode = nextHashCode();

          - 从方法来看,每次生成ThreadLocal都会进行递增HASH_INCREMENT
     
          - ```java
               private static int nextHashCode() {
                   return nextHashCode.getAndAdd(HASH_INCREMENT);
          }
               ```

     - private static AtomicInteger nextHashCode = new AtomicInteger();

          - 类变量 也就是说每个ThreadLocal实例的nextHashCode是不一样的

     - private static final int HASH_INCREMENT = 0x61c88647;

     - static class ThreadLocalMap
     
          -  每一个Thread都会维护一个只属于当前Thread的ThreadLocalMap
     
          - ```java
               // ThreadLocalMap内部又维护了一个Entry,继承了WeakReference<ThreadLocal<?>>
               static class Entry extends WeakReference<ThreadLocal<?>> {
                   /** The value associated with this ThreadLocal. */
                   // 这个value值就是当前线程要存储的值
                   Object value;
                   Entry(ThreadLocal<?> k, Object v) {
                       // 而传进来的ThreadLocal 交给WeakReference,最后会放入 引用队列
                       super(k);
                       value = v;
                   }
               }
               private static final int INITIAL_CAPACITY = 16;
          private Entry[] table;
               private int size = 0;
               private int threshold;
               ```

          - ```
             
               ```
     
     - java.lang.ThreadLocal#set
     
          - ```java
               public void set(T value) {
                   // 获取当前线程
                   Thread t = Thread.currentThread();
                   ThreadLocalMap map = getMap(t);
                   if (map != null)
                       map.set(this, value);
                   else
                       // 第一次进来map肯定是为null,所以要创建个map
                       createMap(t, value);
               }
               // 获取ThreadLocalMap ,从这里可以看出,Thread中维护着一个ThreadLocalMap
               ThreadLocalMap getMap(Thread t) {
                   return t.threadLocals;
               }
               // Thread中的ThreadLocals 超时是null,此处创建一个ThreadLocalMap,key为ThreadLocal, value为set传入的值
               void createMap(Thread t, T firstValue) {
                   t.threadLocals = new ThreadLocalMap(this, firstValue);
               }
               // ThreadLocalMap的构造器,承接上边的createMap
               ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
                   // 初始
                   table = new Entry[INITIAL_CAPACITY];
                   int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
                   table[i] = new Entry(firstKey, firstValue);
                   size = 1;
                   setThreshold(INITIAL_CAPACITY);
               }
               // java.lang.ThreadLocal.ThreadLocalMap#set
               private void set(ThreadLocal<?> key, Object value) {
                   Entry[] tab = table;
                   int len = tab.length;
                 	// 初始len=16 ,并且len始终是2^n ,只有这样len-1的二进制表示的就是地位连续的N个1,
                 	// 假设当前线程初始值 threadLocalHashCode = 1640531527  十进制
                 	// len - 1 的       二进制是 1111, 进行补码 00000000 00000000 00000000 00001111
                   // threadLocalHashCode 的二进制位(直接补码) 01100001 11001000 10000110 01000111
                 	// 那么下边的计算得出结果为
                   // 00000000 00000000 00000000 00000111  --> 111 -> 1*2^2 + 1*2^1 + 1*2^0-> 0+4+2+1=7
                 	// 分析到这也就确定了,当前线程占得table的坑是7,之后当前线程无论多少次ThreadLocal#set 都不会在改变
                 	// 原因在new ThreadLocal<T> 创建实例 时 threadLocalHashCode 的数值已经确定了.
                 	// 需要注意的是 每次new ThreadLocal<T>时threadLocalHashCode 都会以原子性做一个递增操作,而每次都是增加1640531527
                   int i = key.threadLocalHashCode & (len-1);
                   for (Entry e = tab[i];
                        e != null;
                        e = tab[i = nextIndex(i, len)]) {
                    	// e.get() 获取的是一个弱引用的ThreadLocal 	
                     	// 也就是或 当前线程绑定的ThreadLocalMap绑定的弱引用ThreadLocal
                       ThreadLocal<?> k = e.get();
                     	// 如果相等表示是替换value值
                       if (k == key) {
                           e.value = value;
                           return;
                       }
                       // 进入这个条件,也就是说明 出现了gc,并清除了弱引用
                       if (k == null) {
                          
                          replaceStaleEntry(key, value, i);
                          return;
                       }
                   }
                   tab[i] = new Entry(key, value);
                   int sz = ++size;
                   // 如果没有清理并且操作次数大于等于要扩容的条件则进行扩容
                   if (!cleanSomeSlots(i, sz) && sz >= threshold)
                       rehash();
               }
               // java.lang.ThreadLocal.ThreadLocalMap#cleanSomeSlots
               private boolean cleanSomeSlots(int i, int n) {
                   boolean removed = false;
                   Entry[] tab = table;
                   int len = tab.length;
                   do {
                       i = nextIndex(i, len);
                       Entry e = tab[i];
                       if (e != null && e.get() == null) {
                           n = len;
                           removed = true;
                           i = expungeStaleEntry(i);
                       }
                   } while ( (n >>>= 1) != 0);
                   return removed;
               }
               // 调整table大小,删除无用的数据(也就是e.get == null)情况
               // java.lang.ThreadLocal.ThreadLocalMap#rehash
               private void rehash() {
                   expungeStaleEntries();
                   // Use lower threshold for doubling to avoid hysteresis
                   if (size >= threshold - threshold / 4)
                       resize();
               }
               // java.lang.ThreadLocal.ThreadLocalMap#resize
               private void resize() {
                   Entry[] oldTab = table;
                   int oldLen = oldTab.length;
                   int newLen = oldLen * 2;
                   Entry[] newTab = new Entry[newLen];
                   int count = 0;
                   for (int j = 0; j < oldLen; ++j) {
                       Entry e = oldTab[j];
                       if (e != null) {
                           ThreadLocal<?> k = e.get();
                           if (k == null) {
                               e.value = null; // Help the GC
                           } else {
                               int h = k.threadLocalHashCode & (newLen - 1);
                               while (newTab[h] != null)
                                   h = nextIndex(h, newLen);
                               newTab[h] = e;
                               count++;
                           }
                       }
                   }
                   setThreshold(newLen);
                   size = count;
                   table = newTab;
               }
               
               // java.lang.ThreadLocal.ThreadLocalMap#replaceStaleEntry
               private void replaceStaleEntry(ThreadLocal<?> key, Object value,
                                              int staleSlot) {
                   Entry[] tab = table;
                   int len = tab.length;
                   Entry e;
                   // 记录将要删除的slot,这个在清理时是个重要的字段
                   int slotToExpunge = staleSlot;
                   //以staleSlot开始, 向前遍历N个e != null的节点,
                   for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))
                       if (e.get() == null)
                           // 如果e不为空,e的Key也就是ThreadLocal为空,记录下要删除的slot
                           slotToExpunge = i;
                   
               	// 以staleSlot开始,向后遍历N个 e!=nul的节点
                   for (int i = nextIndex(staleSlot, len);(e = tab[i]) != null; i = nextIndex(i, len)) {
                       ThreadLocal<?> k = e.get();
                       if (k == key) {
                           e.value = value;
                           tab[i] = tab[staleSlot];
                           // staleSlot是调用方法时的计算的槽,此处e赋值给他,代表这个就是最新的了
                           tab[staleSlot] = e;
                           if (slotToExpunge == staleSlot)
                               slotToExpunge = i;
                           cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
                           return;
                       }
                       if (k == null && slotToExpunge == staleSlot)
                           slotToExpunge = i;
                   }
                   // If key not found, put new entry in stale slot
                   tab[staleSlot].value = null;
                   tab[staleSlot] = new Entry(key, value);
                   // If there are any other stale entries in run, expunge them
                   if (slotToExpunge != staleSlot)
                       cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
               }
               
               // java.lang.ThreadLocal.ThreadLocalMap#expungeStaleEntry 
               // 清理方法,不做注释了
               private int expungeStaleEntry(int staleSlot) {
                   Entry[] tab = table;
                   int len = tab.length;
                	// 置空
                   tab[staleSlot].value = null;
                   tab[staleSlot] = null;
                   size--;
               
                   Entry e;
                   int i;
                   // 继寻找e!=null的下一个节点,
                   for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
                       ThreadLocal<?> k = e.get();
                       if (k == null) {
                           e.value = null;
                           tab[i] = null;
                           size--;
                       } else {
                           int h = k.threadLocalHashCode & (len - 1);
                           if (h != i) {
                               tab[i] = null;
                               while (tab[h] != null)
                                   h = nextIndex(h, len);
                               tab[h] = e;
                           }
                       }
                   }
                   return i;
               }
               
               ```
     
     - java.lang.ThreadLocal#get
     
          - ```java
               public T get() {
                   Thread t = Thread.currentThread();
                   ThreadLocalMap map = getMap(t);  // Thread.threadLocals
                   if (map != null) {
                       ThreadLocalMap.Entry e = map.getEntry(this);
                       if (e != null) {
                           @SuppressWarnings("unchecked")
                           T result = (T)e.value;
                           return result;
                       }
                   }
                   return setInitialValue();
               }
               // java.lang.ThreadLocal.ThreadLocalMap#getEntry
               private Entry getEntry(ThreadLocal<?> key) {
                   int i = key.threadLocalHashCode & (table.length - 1);
                   Entry e = table[i];
                   if (e != null && e.get() == key)
                       return e;
                   else
                       return getEntryAfterMiss(key, i, e);
               }
               
               // java.lang.ThreadLocal.ThreadLocalMap#getEntryAfterMiss
               // 该方法通过一个while条件获取entry,直到 找到与当先线程相等的ThreadLocal
               // 如果找不到,直接返回空
               // 该方法也涉及删除无效的entry
               private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
                   Entry[] tab = table;
                   int len = tab.length;
                   while (e != null) {
                       ThreadLocal<?> k = e.get();
                       if (k == key)
                           return e;
                       if (k == null)
                           expungeStaleEntry(i);
                       else
                           i = nextIndex(i, len);
                       e = tab[i];
                   }
                   return null;
               }
               ```
     
     - java.lang.ThreadLocal#remove
     
          - ```
               private void remove(ThreadLocal<?> key) {
                   Entry[] tab = table;
                   int len = tab.length;
                   int i = key.threadLocalHashCode & (len-1);
                   for (Entry e = tab[i];
                        e != null;
                        e = tab[i = nextIndex(i, len)]) {
                       if (e.get() == key) {
                           e.clear();
                           expungeStaleEntry(i);
                           return;
                       }
                   }
               }
               ```

### J.U.C

- 中断
  - 关键方法
    - java.lang.Thread#isInterrupted()   --- public boolean isInterrupted()
      - 会调用private native boolean isInterrupted(boolean ClearInterrupted) 本地方法,true代表重置,false代表不重置,此处ClearInterrupted=false
      -  测试线程是否已经中断。线程的中断状态不受该方法的影响
    - java.lang.Thread#interrupted   --- public static boolean interrupted()
      - 会调用private native boolean isInterrupted(boolean ClearInterrupted) 本地方法,true代表重置,false代表不重置,此处ClearInterrupted=true
      - 测试当前线程是否已经中断。如果线程处于中断状态返回true，否则返回false。同时该方法将清除的线程的中断状态。即，如果连续两次调用该方法，则第二次调用将返回 false。该方法可用于清除线程中断状态使用。
      - 
    - java.lang.Thread#interrupt ---- public void interrupt()
      - 中断线程
- 
  
 - AQS (抽象的队列同步器) [源码解读](https://www.cnblogs.com/waterystone/p/4920797.html)

    - ![](CLH队列.png)

    - AQS中维护一个CLH变种的双端队列,和一个volatile 修饰的state字段

       - state 字段 0 值表示空闲没有任何线程占用,大于0表示有线程正在使用
       - Node 内部类
          - static final Node SHARED = new Node();   共享锁标识
          - static final Node EXCLUSIVE = null; // 共享锁
          - static final int CANCELLED =  1; 
          - static final int SIGNAL    = -1;
          - static final int CONDITION = -2;
          - static final int PROPAGATE = -3;
          - volatile int waitStatus; //初始值 0
          - volatile Node prev; 前指针
          - volatile Node next; 后指针
          - volatile Thread thread; 当前node的线程
          - Node nextWaiter;
       - Node head 头结点
       - Node tail 尾节点

    - 流程 (以ReentrantLock为例)

       - new ReentrantLock() 初始化,默认使用非公平锁(NonfairSync)

       - lock

         - ```java
           final void lock() {
               if (compareAndSetState(0, 1))
                   setExclusiveOwnerThread(Thread.currentThread());
               else
                   acquire(1);
           ```

           

         - 当state=0时也就是说没有任何线程占用锁,cas操作成功,将state从0设置成1,并且返回true,然后设置拥有锁的线程,也就是当前线程

         - 当state !=0,也就是已经有线程占有锁了,表示cas操作失败,进入acquire(1);方法

         - ```java
           public final void acquire(int arg) {
               if (!tryAcquire(arg) &&
                   acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                   // 当acqioreQueued返回true则表示当前线程不是被unpark唤醒的,是被其他线程中断唤醒的,所以要自我中断一次,将中断标志位设为true
                   // 原因是因为,当前线程在阻塞时没有及时响应中断信号,现在要进行补偿,这样的话,如果该线程在lock代码块内部调用sleep()之类的阻塞方法
                   // 就可以抛出异常,响应中断
                 selfInterrupt();
           }
           ```
           
         - 此时tryAcquire(arg)会再次尝试获取一下锁,如果成功后边的方法就不用再执行了

           - ```java
             protected final boolean tryAcquire(int acquires) {
                 return nonfairTryAcquire(acquires);
             }
             final boolean nonfairTryAcquire(int acquires) {
                 // 获取当前线程
                 final Thread current = Thread.currentThread();
                 int c = getState();
                 // 如果c = 0 也就是state=0尝试cas强锁
                 if (c == 0) {
                     // 强锁成功的话设置当前线程为持有锁线程并返回true
                     if (compareAndSetState(0, acquires)) {
                         setExclusiveOwnerThread(current);
                         return true;
                     }
                 }
                 // 如果c!=0 也就是state!=0判断,持有锁的线程是不是当前线程(重入锁逻辑)
                 else if (current == getExclusiveOwnerThread()) {
                     int nextc = c + acquires;
                     if (nextc < 0) // overflow
                         throw new Error("Maximum lock count exceeded");
                     setState(nextc);
                     return true;
                 }
                 return false;
             }
             ```

         - 当tryAcquire(arg) 失败,则继续向后执行

           - ```java
             private Node addWaiter(Node mode) {
             	// 创建一个node节点,mode 区分为 共享锁/独占锁,此处是以ReentrantLock为例,
             	// 所以此处是独占锁Node.EXCLUSIVE
                 Node node = new Node(Thread.currentThread(), mode);
                 // 将尾节点赋值给pred
                 Node pred = tail;
                 if (pred != null) {
                     node.prev = pred;
                     // 将新创建的node设置成尾节点
                     if (compareAndSetTail(pred, node)) {
                         pred.next = node;
                         return node;
                     }
                 }
                 enq(node);
                 return node;
             }
             private Node enq(final Node node) {
             	// 一个自旋
                 for (;;) {
                     Node t = tail;
                     // 第一次进来t 肯定是null
                     if (t == null) { // Must initialize
                     	// 此处创建了一个node实例并将这个实例放置到头结点
                         // 该节点也叫哨兵节点/傀儡节点,只是占位使用
                         if (compareAndSetHead(new Node()))
                         	如果CAS设置成功 将将尾节点赋值
                             tail = head;
                     } else {
                         //当 t != null时进入此处
                         node.prev = t;
                         //CAS 操作将尾节点设置成enq入参的node
                         if (compareAndSetTail(t, node)) {
                             // CAS 操作成功,设置t的next节点为node并返回
                             t.next = node;
                             return t;
                         }
                     }
                 }
             }
             ```

             - enq第一次图(t==null)![](enq_one.png)
             - enq第二次图(t!=null)![](enq_two.png)

         - enq方法执行完成后执行acquireQueued(final Node node, int arg) 方法

           - ```java
             final boolean acquireQueued(final Node node, int arg) {
                 boolean failed = true;
                 try {
                     boolean interrupted = false;
                     // 自旋
                     for (;;) {
                         // 获取node的前置节点,该方法会抛出一个npe异常
                         final Node p = node.predecessor();
                         //如果node的前置节点是头结点,则再次尝试抢锁
                         if (p == head && tryAcquire(arg)) {
                             // 抢锁成功设置当前节点为头节点也就是傀儡节点
                             setHead(node);
                             // 将之前的头结点next引用改为null,方便gc
                             // 换句话说就是之前的头结点p已经给任何node没有应用关系了
                             p.next = null; // help GC
                             failed = false;
                             return interrupted;
                         }
                         // 当shouldParkAfterFailedAcquire=true
                         // parkAndCheckInterrupt=false (表示未被中断)
                         // parkAndCheckInterrupt=true (表示被中断) 并赋值interrupted = true;
                         // 此时线程已被前一个node节点唤醒,并且前一个节点已经晋升为头结点,当前线程开始进入下一次自旋
                         if (shouldParkAfterFailedAcquire(p, node) &&
                             parkAndCheckInterrupt())
                             interrupted = true;
                     }
                 } finally {
                     if (failed)
                         cancelAcquire(node);
                 }
             }
             private void setHead(Node node) {
                 head = node;
                 node.thread = null;
                 node.prev = null;
             }
             private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
                 int ws = pred.waitStatus;
                 if (ws == Node.SIGNAL)
                     /*
                      * This node has already set status asking a release
                      * to signal it, so it can safely park.
                      */
                     return true;
                 if (ws > 0) {
             		// 当被取消的线程才会进入这里
                     do {
                         node.prev = pred = pred.prev;
                     } while (pred.waitStatus > 0);
                     pred.next = node;
                 } else {
             		// waitStatus的默认值是0,所以第一次进来会进入这里
                     // 执行一个CAS操作,将waitStatus 赋值成SINNAL(-1)
                     compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
                 }
                 return false;
             }
             private final boolean parkAndCheckInterrupt() {
                 // 挂起线程 阻塞在这里了,等待被unpark
                 LockSupport.park(this);
                 // 获取当前线程是否被中断过,并恢复默认中断状态(false)
                 return Thread.interrupted();
             }
             ```

       - 释放锁

         - ```java
           public void unlock() {
               sync.release(1);
           }
           public final boolean release(int arg) {
               if (tryRelease(arg)) {
                   Node h = head;
                   if (h != null && h.waitStatus != 0)
                       unparkSuccessor(h);
                   return true;
               }
               return false;
           }
           protected final boolean tryRelease(int releases) {
               int c = getState() - releases;
               // 在释放锁时,如果不是当前线程占有的锁,则抛出异常
               if (Thread.currentThread() != getExclusiveOwnerThread())
                   throw new IllegalMonitorStateException();
               boolean free = false;
               // 如果c==0表示可以释放锁了,如果非0表示当前线程是重入锁
               if (c == 0) {
                   free = true;
                   setExclusiveOwnerThread(null);
               }
               // 直接setState值,而不是使用CAS,因为reentranLock的addWaiter(Node.EXCLUSIVE) 用的是排它锁,
               // 所以此时直接set即可,此时是没有线程来抢锁的
               setState(c);
               return free;
           }
           // node 传进来的是头结点,也是当前线程的node节点
           private void unparkSuccessor(Node node) {
                   int ws = node.waitStatus;
                   if (ws < 0)
                       compareAndSetWaitStatus(node, ws, 0);
                   Node s = node.next;
                   if (s == null || s.waitStatus > 0) {
                       s = null;
                       for (Node t = tail; t != null && t != node; t = t.prev)
                           if (t.waitStatus <= 0)
                               s = t;
                   }
                   if (s != null)
                       // 唤醒下一个线程
                       
                       LockSupport.unpark(s.thread);
               }
           ```

- ThreadPoolExecutor
  - 构造方法参数
    - int corePoolSize       
    - int maximumPoolSize
    - long keepAliveTime
    - TimeUnit unit
    - BlockingQueue<Runnable> workQueue
    - ThreadFactory threadFactory
    - RejectedExecutionHandler handler
    
  - 成员变量和类变量

    - ```java
      // 初始 -536870912
      // 该字段控制状态,ctl 封装了 两个字段
      // workerCount 有效的线程数量
      // runState 该字段表明当前线程池 是否是在运行或者停止等等
      // ctl一个变量同时存储runState和workerCount，其中runState占用高3位，workCount占用低29位
      private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
      private static final int COUNT_BITS = Integer.SIZE - 3;  // 29
      //00011111 11111111 11111111 11111111
      private static final int CAPACITY   = (1 << COUNT_BITS) - 1; // 536870911
      // runState is stored in the high-order bits 
      // 11100000 00000000 00000000 00000000
      private static final int RUNNING    = -1 << COUNT_BITS; // -536870912
      // 00000000 00000000 00000000 00000000
      private static final int SHUTDOWN   =  0 << COUNT_BITS; // 0
      // 00100000 00000000 00000000 00000000
      private static final int STOP       =  1 << COUNT_BITS; // 536870912
      // tidying  [ˈtaɪdiɪŋ]  使整洁;使整齐 ;使有条理;整理
      // 01000000 00000000 00000000 00000000
      private static final int TIDYING    =  2 << COUNT_BITS; // 1073741824
      // terminated [ˈtɜːmɪneɪtɪd] 终止,结束
      // 01100000 00000000 00000000 00000000
      private static final int TERMINATED =  3 << COUNT_BITS; // 1610612736
      
      // Packing and unpacking ctl
      // 解析出来 runState
      private static int runStateOf(int c)     { return c & ~CAPACITY; }
      // worker线程数量
      private static int workerCountOf(int c)  { return c & CAPACITY; }
      private static int ctlOf(int rs, int wc) { return rs | wc; }
      ```

  - 任务提交过程 (java.util.concurrent.ThreadPoolExecutor#execute)
    1. 判断当前工作线程数量是否小于核心线程
       1. 小于核心线程则,新建个线程

# spring

## 事务

## MVC调用过程

## Bean生命周期

## Bean 循环依赖

## spring.handles 文件

## BeanFactory 和 FactoryBean<T>

## spring一些类说明

### class

- AbstractAutowireCapableBeanFactory
  - 实例化bean
  - 属性填充
  - 初始化bean
  - 三级缓存
- DefaultListableBeanFactory
- AbstractApplicationContext
- LazyInitializationBeanFactoryPostProcessor
- AbstractBeanDefinition
- PostProcessorRegistrationDelegatez
- SimpleApplicationEventMulticaster
- ConfigurationClassPostProcessor
- CommonAnnotationBeanPostProcessor
  - 类层次
    - 继承 InitDestroyAnnotationBeanPostProcessor   
    - 实现 InstantiationAwareBeanPostProcessor
    - 实现 BeanFactoryAware
    - 实现 Serializable
  - 
- AutowiredAnnotationBeanPostProcessor
  - 间接实现两种BeanPostProcessor
    - SmartInstantiationAwareBeanPostProcessor
      - determineCandidateConstructors(构造器实例化推断)
        - 调用时机:实例化之前
        - 在实例化bean之前调用,用来推断是否是通过有参构造器实例化还是用无参构造器初始化.
          - AbstractAutowireCapableBeanFactory#autowireConstructor(有参数构造器构建)
          - AbstractAutowireCapableBeanFactory#instantiateBean (无参构造器实例化)
        - lookup处理,如果存在lookup注解,则包装一个 LookupOverride override = new LookupOverride(method, lookup.value())类,然后将lookup包装后实例 放入 RootBeanDefinition.methodOverrides(字段中维护了一个Set集合,说明可以有多个lookup注解) 字段中,便于以后使用,CGLIB提升.
      - postProcessProperties
        - 调用时机:实例化之后,填充属性
        - 属性注入 包括@autowired  @value  @javax.inject.Inject
        - 内部类
          - AutowiredFieldElement extends InjectionMetadata.InjectedElement
          - AutowiredMethodElement extends InjectionMetadata.InjectedElement
          - 以上两个类包装 要注入的属性
    - MergedBeanDefinitionPostProcessor
      - postProcessMergedBeanDefinition
        - 调用时机:目标bean实例化后
  - 实现 BeanFactoryAware,主要作用 aware回调 setBeanFactory
  - 实现 PriorityOrdered 接口
    - 用于排序,该接口继承Order接口,无任何方法,算是个标识,在排序逻辑中PriorityOrdered比Order接口更强
- SimpleTypeConverter
- ResourceEditorRegistrar
  - registerCustomEditors
- PropertyPlaceholderHelper
- SmartInitializingSingleton
- PropertySourcesPropertyResolver
- AbstractPropertyResolver
- AbstractBeanFactory
- SimpleInstantiationStrategy
- InitDestroyAnnotationBeanPostProcessor

### interface

- InstantiationAwareBeanPostProcessor
- MergedBeanDefinitionPostProcessor
  - void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)
    - 在bean实例化之后,立即调用可以修改beandefinition中的properties ,或缓存一些meta信息例如
  - void resetBeanDefinition(String beanName) 
    - 该方法是根据beanName 重置beandefinition
- BeanPostProcessor
  - Object postProcessBeforeInitialization(Object bean, String beanName)
    - 该方法在bean属性注入之后执行,自定义 init方法或InitializingBean的afterPropertiesSet方法之前
    - 返回一个原始bean或包装后的bean,如果返回null,就不会在执行后续的BeanPostProcessors的子类了
  - Object postProcessAfterInitialization(Object bean, String beanName)
    - 在执行InitializingBean#afterPropertiesSet()方法或自定义init方法后执行
    - 返回一个原始的bean或包装过的bean,如果返回null,就不会在执行后续的BeanPostProcessors的子类了
- BeanDefinition
- ApplicationContext
- BeanFactoryPostProcessors
- Lifecycle
- DisposableBean
- ApplicationContextInitializer
- ConversionService
- ObjectFactory<T>
  - objectfactory设计是用来对特定bean进行加工的，比如需要进行aop代理，需要对bean个性化的时候可以用objectfactory包装一下，objectprovider一般是spring内部实现某一个功能时可能有考虑不到的地方，spring抽象一个接口类型然后通过objectprovide来进行延长查找你实现了这些接口的类，一般会设计成链式调用，我个人的理解是objectfactory用来增强bean的功能，objectprovide+特点功能扩展接口，来实现把我们的功能和spring内部逻辑整合，比如@configurationpropertys不能解析spel表达式但是spring提供了扩展接口和objectprovide功能，我通过这2个地方扩展出来使得@configurationpropertys也能像@value一样支持spel表达式（springboot2.3才支持的！）
- InstantiationStrategy
- InjectionMetadata
- CglibSubclassingInstantiationStrategy
- DestructionAwareBeanPostProcessor

## Spring boot是如何内嵌TOMCAT的?

## Spring annotation

- @LookUp,单例引用原型(prototype)
  - 解释:Spring容器中单例A通过@Autowired或@resource 引入原型Bean,会出现原型bean变成了单例,而不是每次调用都会创建成新的实例所以lookup可以解决




